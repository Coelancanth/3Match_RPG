# 骰子架构设计思路及实现步骤

先明确思路：引入骰子系统（Dice System）。

- 每个骰子有6个面，对应6个可能触发的技能（可能为空）
    
    - 技能的本质是一个特殊的元素（技能元素）
    - 这些技能之后可以被替换
    - 可以被升级
    - 对它们的影响可以是通过Relic，比如有的Relic可以将骰子的某个特定面替换为某个特定的技能，或者将整个骰子的技能升级
    - 也可以是受到敌人的攻击（比如有会石化的敌人，在受到这个敌人的石化技能攻击后，骰子的一面会被石化，不能再使用）
- 不同类型的骰子（如【元素骰子】【火系骰子】【水系骰子】）在玩家选择“掷出”后掷出，根据结果自动在网格中生成相应的元素。
    
- 不同职业有不同的初始骰子组成（如【元素使】这个职业的初始骰子是【元素骰子】，其中的两个面是空白，四个面分别对应四个元素（火、水、气、地）的基本攻击魔法技能，每投掷一颗骰子，棋盘上会有4个元素生成（【元素骰子】本身会生成3个元素，每个元素类别（火、水、气、地）的概率为1/4，同时还有1个技能元素）。
    
- 技能除了能够伤害格子上的敌人，还可以作用于格子上已有的元素，或者造成地形的影响，比如火球是范围攻击，会让范围内燃烧/将范围内的火元素升级，如果再触发了降雨技能，则在重合范围内，可能会导致蒸汽的产生/水元素的升级/火元素的消失或者等级下降
    
- 因此在玩家投掷完骰子，手动移动棋盘上的元素，进行匹配，匹配算法运行之后，会因为技能的触发/元素的变化/地形的影响而出现一系列的连锁反应与涌现式设计机制，在设计架构的时候尤其要考虑这点。
    
- [ ] 增加骰子预览功能，在使用调试命令时可以可视化展示骰子信息
    

### 阶段一：核心骰子系统开发

**目标**：建立基础的骰子机制，包括骰子的创建、掷骰子以及在棋盘上生成基本元素。

1. **定义基础数据结构**
    - 创建`ElementData`、`SkillData`、`DiceFaceData`和`DiceData`的`ScriptableObject`类，用于定义元素类型、技能效果和骰子面。
    - 确保每个`DiceData`包含6个`DiceFaceData`，并定义支持的元素类型及其权重。
2. **实现骰子创建与管理**
    - 编写`Dice`类，管理骰子的状态、升级和替换机制。
    - 使用单例模式或依赖注入管理骰子库，确保全局唯一性和易于访问。
3. **实现骰子掷出逻辑**
    - 编写`DiceManager`类，负责管理所有骰子并处理掷骰子操作。
    - 实现`RollAllDice()`方法，随机生成骰子面并调用`GridManager`生成对应元素。
4. **设计棋盘系统**
    - 创建`GridManager`类，管理棋盘网格的初始化、元素生成和布局。
    - 实现元素在棋盘上的基本显示和管理接口，如`GenerateElements(DiceFaceData face)`。
5. **基本测试**
    - 创建测试场景，包含`DiceManager`和`GridManager`，验证骰子创建、掷骰子和元素生成是否正常工作。
    - 确保元素在棋盘上的正确生成和显示，没有明显的功能错误。

**验收标准**：

- 骰子系统能够正确创建和管理不同类型的骰子。
- 玩家可以通过掷骰子生成元素，并在棋盘上正确显示。
- 基础骰子掷出和元素生成流程无明显错误，游戏能够在最简单层面正常运行。

---

### 阶段二：技能系统集成

**目标**：引入骰子面对应的技能，定义技能效果并实现其在棋盘上的作用。

1. **定义技能类型**
    - 创建`SkillEffectType`枚举，列出所有技能效果类型（如Fireball、WaterSplash等）。
    - 实现`ISkillEffect`接口及其具体技能效果类（如`FireballEffect`、`WaterSplashEffect`）。
2. **实现技能触发机制**
    - 编写`SkillManager`类，负责管理和触发技能效果。
    - 实现`TriggerSkill(SkillData skill, Vector2 position, GridManager gridManager)`方法，通过工厂模式创建并执行技能效果。
3. **实现特殊元素**
    - 创建`SpecialElement`类，继承自`Element`类，添加特殊行为和属性。
    - 创建`PassiveSpecialElement`类，继承自`SpecialElement`类，特有`isTriggered`方法
    - 创建`ActiveSpecialElement`类，继承自`SpeialElement`类，特有`isTriggered`方法，以及`Trigger`方法
    - 定义各种特殊元素（如炸弹、万能符号等）并实现其在棋盘上的行为逻辑。
4. **元素与技能的交互**
    - 在`GridManager`中实现技能对棋盘上现有元素的作用逻辑，如火球对范围内元素的燃烧效果。
    - 处理地形影响，如降雨导致蒸汽产生等。
5. **测试与验证**
    - 创建多个技能实例，验证技能触发和效果的正确性。
    - 测试技能与元素的交互，确保连锁反应正常。

**验收标准**：

- 技能系统能够正确识别和触发不同类型的技能。
- 技能效果在棋盘上正确应用，能够影响目标元素或地形。
- 特殊元素行为符合设计预期，能够与技能系统无缝集成。

---

### 阶段三：Relic（遗物）与升级系统

**目标**：实现遗物系统，使玩家能够通过遗物修改骰子面、升级技能，并提升骰子的整体能力。

1. **定义遗物数据结构**
    - 创建`RelicData`的`ScriptableObject`类，定义遗物名称、描述、效果类型、目标技能和替换面等属性。
    - 定义`RelicEffectType`枚举，列出所有遗物效果类型（如ReplaceFace、UpgradeSkill等）。
2. **实现遗物功能**
    - 编写`RelicManager`类，管理玩家拥有的遗物，并应用遗物效果。
    - 实现`ApplyRelic(RelicData relic, Dice dice, int faceIndex)`方法，根据遗物类型执行相应操作。
3. **升级系统**
    - 创建`UpgradeManager`类，管理技能和骰子的升级路径，处理升级逻辑。
    - 实现`UpgradeSkill(SkillData skill)`和`UpgradeDice(Dice dice)`方法，处理技能和骰子的升级。
4. **用户界面（UI）集成**
    - 设计并实现遗物管理界面，允许玩家查看、装备和使用遗物。
    - 设计升级界面，展示技能和骰子的升级选项，并提供交互功能。
5. **测试与平衡**
    - 测试遗物的各项功能，确保其能够正确修改和升级骰子。
    - 调整遗物效果的强度，确保游戏的平衡性和多样性。

**验收标准**：

- 遗物系统能够正确应用不同类型的遗物效果，修改骰子面或升级技能。
- 升级系统能够提升技能和骰子的能力，且升级路径清晰合理。
- UI界面能够直观展示遗物和升级选项，玩家操作流畅无误。

---

### 阶段四：敌人互动与骰子修改机制

**目标**：引入敌人系统，使敌人的攻击能够影响玩家的骰子，增加游戏的战略深度。

1. **定义敌人类型**
    - 创建`EnemyData`的`ScriptableObject`类，定义敌人名称、效果类型、攻击力等属性。
    - 定义`EnemyEffectType`枚举，列出所有敌人效果类型（如Petrify、FireDamage等）。
2. **实现敌人攻击机制**
    - 编写`Enemy`类，包含敌人的数据和攻击逻辑。
    - 实现`Attack()`方法，根据敌人效果类型对玩家骰子执行相应操作。
3. **骰子状态管理**
    - 扩展`Dice`类，添加状态属性如`isFaceFrozen`，标记某个骰子面是否被冻结。
    - 实现`PetrifyFace(int faceIndex)`方法，冻结指定骰子面，并在`Roll()`方法中忽略被冻结的面。
4. **敌人行为逻辑**
    - 创建`EnemyAI`类，管理敌人的移动、攻击和能力触发逻辑。
    - 实现定时攻击机制，如每隔一定时间执行一次攻击。
5. **用户界面（UI）更新**
    - 在骰子显示上标注被冻结的面（如覆盖图标或改变颜色）。
    - 显示敌人的状态和攻击信息（如生命值、状态效果）。
6. **测试与调整**
    - 测试敌人攻击对骰子的影响，确保功能正常。
    - 调整敌人攻击频率和强度，确保游戏难度适中。

**验收标准**：

- 敌人能够正确攻击玩家骰子，冻结指定的骰子面。
- 冻结的骰子面在掷骰子时被忽略，无法使用。
- UI能够直观展示骰子面被冻结的状态及敌人攻击信息。

---

### 阶段五：多种骰子类型与职业系统

**目标**：引入不同类型的骰子和职业，使玩家可以选择不同的游戏风格和策略。

1. **定义不同骰子类型**
    - 扩展`DiceTypeData`的`ScriptableObject`类，为每种骰子类型定义独特的元素和技能。
    - 创建不同类型的骰子（如火系、水系、气系、地系、万能骰子等），并配置其属性和技能。
2. **实现职业系统**
    - 创建`ClassData`的`ScriptableObject`类，定义不同职业的名称、初始骰子组合和起始遗物等属性。
    - 编写`Player`类，包含玩家选择的职业、拥有的骰子和遗物。
3. **骰子类型逻辑**
    - 扩展`DiceManager`类，根据骰子类型生成对应的元素和触发特定技能。
    - 确保不同骰子类型之间的互补和平衡，避免某些类型过于强大或弱小。
4. **用户界面（UI）集成**
    - 设计职业选择界面，展示不同职业的初始骰子和能力，允许玩家选择。
    - 在游戏过程中显示不同骰子类型的标识和信息，帮助玩家识别和管理骰子。
5. **测试与平衡**
    - 测试不同职业和骰子类型的组合，确保其玩法多样且平衡。
    - 根据测试反馈调整骰子类型的元素生成概率和技能效果，优化游戏体验。

**验收标准**：

- 玩家能够在游戏开始时选择不同职业，每个职业拥有独特的初始骰子和能力。
- 不同骰子类型在游戏中能够正确生成对应元素和触发特定技能。
- 职业和骰子类型的组合多样且平衡，提供多种游戏策略选择。

---

### 阶段六：高级匹配算法与连锁反应

**目标**：开发复杂的匹配算法，支持技能触发、元素变化和连锁反应，提升游戏的策略性和动态性。

1. **设计匹配逻辑**
    - 编写`MatchManager`类，负责检测和处理匹配条件（如三消、四消、五消等）。
    - 实现`FindAllMatches()`方法，扫描棋盘找出所有符合条件的元素组合。
2. **实现技能与元素互动**
    - 在`SkillManager`中实现不同技能对元素的作用逻辑，如范围攻击、元素升级等。
    - 确保技能效果能够正确影响目标元素或地形。
3. **连锁反应机制**
    - 在`MatchManager`中实现连锁反应处理，允许一次匹配触发多次技能效果和元素变化。
    - 使用递归或迭代方法，确保所有连锁反应能够被正确检测和处理。
4. **地形影响**
    - 在`GridManager`中实现地形变化对元素和技能的影响，如蒸汽生成、水元素消失等。
    - 确保地形变化能够动态反映在棋盘上，并影响后续的匹配和技能触发。
5. **优化与性能**
    - 优化`MatchManager`和`GridManager`的匹配检测算法，提升性能。
    - 使用协程或异步处理复杂的连锁反应，避免主线程阻塞。
6. **测试与验证**
    - 通过多种场景测试匹配和连锁反应，确保逻辑正确。
    - 根据测试结果调整匹配条件和技能效果，提升游戏体验。

**验收标准**：

- 匹配算法能够准确检测所有符合条件的元素组合。
- 技能触发和元素变化能够正确引发连锁反应，产生预期的游戏效果。
- 游戏在处理大量连锁反应时依然保持流畅，无明显的性能问题。

---

### 阶段七：用户界面（UI）与用户体验（UX）优化

**目标**：提升游戏的视觉表现和用户体验，确保玩家能够直观地理解和操作游戏机制。

1. **设计游戏界面**
    - 创建主`Canvas`，包含棋盘区域、骰子区域、技能栏、遗物栏和信息展示区域等。
    - 设计直观的菜单、按钮和信息展示区域，确保布局合理、美观。
2. **动画与视觉效果**
    - 使用`Animator`和`Animation Clips`为骰子掷出、元素生成和技能触发等添加动画效果。
    - 使用`Particle System`创建爆炸、火焰、水花等视觉特效，增强游戏的视觉表现。
3. **用户交互**
    - 编写交互脚本，实现拖动元素、点击技能和应用遗物等功能。
    - 添加提示和引导，帮助新手玩家理解游戏机制，如使用箭头、文字说明等。
4. **声音与音效**
    - 创建`AudioManager`类，管理所有游戏音效和背景音乐。
    - 添加掷骰子、技能触发、元素消除等动作的音效，增强游戏氛围。
5. **响应式设计**
    - 配置`Canvas Scaler`组件，确保UI在不同设备和分辨率下良好显示。
    - 使用布局组件（如`Grid Layout Group`、`Vertical Layout Group`）自动适配不同屏幕尺寸。
6. **测试与反馈**
    - 进行用户测试，收集玩家对UI和UX的反馈。
    - 根据反馈调整UI布局、交互方式和视觉效果，提升整体用户体验。

**验收标准**：

- 游戏界面美观且布局合理，玩家能够轻松找到各个功能区。
- 动画和视觉效果流畅，增强了游戏的视觉体验。
- 用户交互直观且响应迅速，玩家能够轻松操作游戏机制。
- 声音与音效契合游戏氛围，提升了整体沉浸感。

---

### 阶段八：平衡调整与最终测试

**目标**：确保游戏机制平衡，修复所有潜在的bug，并准备上线发布。

1. **平衡性调整**
    - 根据测试数据调整`ScriptableObject`中的参数，如骰子生成概率、技能强度和敌人难度等。
    - 确保不同职业和骰子类型之间的平衡，避免某些组合过于强大或弱小。
2. **Bug 修复**
    - 使用Unity的调试工具（如`Debug.Log`、`Profiler`）检测并修复所有已知的bug和漏洞。
    - 确保游戏在各种情况下都能稳定运行，无明显的功能错误或崩溃。
3. **性能优化**
    - 优化关键算法和数据结构，减少不必要的计算和内存使用。
    - 压缩和优化纹理、音频等资源，减少加载时间和内存占用。
    - 使用`Occlusion Culling`、合批等技术提升渲染性能，确保游戏在低端设备上也能流畅运行。
4. **最终测试**
    - 进行全面的功能测试、性能测试和用户体验测试，确保所有功能正常工作。
    - 邀请内部和外部测试人员进行试玩，收集更多真实的反馈和bug报告。
5. **准备发布**
    - 配置正确的构建设置（如分辨率、平台、质量设置），完成游戏的打包。
    - 完成用户手册、帮助系统和发布说明等文档，确保玩家能够顺利上手游戏。
    - 确保游戏符合目标发布平台（如Steam、App Store、Google Play）的要求，完成相关的打包和提交流程。
6. **上线与后续支持**
    - 将游戏发布到目标平台，监控其运行状态和用户反馈。
    - 准备后续的更新和维护计划，根据玩家反馈进行改进和添加新内容，保持游戏的活力和玩家的参与度。

**验收标准**：

- 游戏机制经过平衡调整，所有职业和骰子类型均衡且玩法多样。
- 所有已知的bug和漏洞被修复，游戏运行稳定，无明显的功能错误。
- 性能优化后，游戏在不同设备上均能流畅运行，加载时间合理。
- 最终测试通过，玩家反馈积极，准备上线发布。
- 发布流程顺利完成，游戏成功上线并获得初步的用户反馈。

---

---
### 阶段九：百科全书功能

**目标**：开发一个百科全书系统，允许玩家查询游戏中的所有元素、技能、职业等详细信息，增加游戏的丰富性和教育性。

1. **定义数据结构**
    - 创建`EncyclopediaEntry`的`ScriptableObject`类，用于存储和管理条目的名称、描述、图片和其他相关信息。

2. **界面设计**
    - 设计百科全书界面，包括分类浏览、搜索框和详细信息展示区域。
    - 使用分页或滚动列表展示条目，提供一个用户友好的界面。

3. **实现百科全书功能**
    - 编写`EncyclopediaManager`类，负责管理百科全书的条目并处理界面的显示逻辑。
    - 实现搜索和筛选功能，让玩家可以根据关键词或类别快速找到信息。

4. **用户交互**
    - 允许玩家通过点击条目查看详细信息，如元素的属性、技能效果的详细描述等。
    - 提供返回和导航功能，确保用户可以方便地浏览不同条目。

5. **测试与反馈**
    - 进行用户测试，收集反馈以改进百科全书的内容和用户界面。
    - 确保所有功能正常运行，信息准确无误。

**验收标准**：
- 百科全书功能能够正确显示所有预设条目。
- 界面美观易用，玩家可以方便地浏览和搜索信息。
- 信息内容丰富准确，增强玩家对游戏世界的理解和兴趣。

---
### 阶段十：MOD支持

**目标**：实现MOD支持功能，允许玩家和开发者自定义和扩展游戏内容，增加游戏的可玩性和持久性。

1. **开发API**
    - 定义一套开放的API，允许访问和修改游戏的核心数据结构，如元素类型、技能、职业等。
    - 确保API的安全性和稳定性，避免游戏运行中出现问题。

2. **模块化设计**
    - 将游戏核心功能模块化，使之能够通过外部文件（如XML或JSON）进行配置和修改。
    - 提供详细的模块和属性说明，便于MOD开发者理解和使用。

3. **工具和文档提供**
    - 提供MOD制作工具，如编辑器插件，简化MOD的创建和测试过程。
    - 编写详细的MOD开发文档，包括API使用、常见问题解答和最佳实践指南。

4. **社区和平台建设**
    - 建立一个MOD社区平台，允许用户上传、下载和评价MOD。
    - 提供技术支持和社区管理，确保平台的活跃性和秩序。

5. **测试和兼容性保证**
    - 进行广泛的MOD兼容性测试，确保MOD不会影响游戏的稳定性。
    - 提供一个反馈机制，让玩家和开发者报告和修复由MOD引起的问题。

**验收标准**：
- MOD系统能够正确加载和执行用户自定义的MOD。
- 提供的API和工具能够覆盖游戏的主要可扩展功能。
- 社区活跃，用户能够方便地分享和讨论MOD。

---




## **总结**

通过以上八个阶段的实施计划，结合Unity3D的代码架构和设计模式，您可以系统化地开发和完善骰子系统及相关的技能系统。每个阶段都有明确的目标和任务，确保项目能够逐步推进并最终实现预期的游戏体验。建议在每个阶段结束后进行评估和反馈，以便及时调整计划和优化设计，确保项目的成功完成。

### **推荐的设计模式和工具**

- **设计模式**
    - **工厂模式**：用于创建技能、敌人和骰子等实例，简化对象创建过程。
    - **单例模式**：用于管理全局系统，如`AudioManager`、`GameManager`，确保唯一性。
    - **观察者模式**：用于实现事件驱动的系统，如技能触发、连锁反应，提升系统的解耦性。
    - **策略模式**：用于处理不同职业和骰子类型的行为逻辑，提升代码的灵活性和可扩展性。
- **工具和插件**
    - **ScriptableObject**：用于数据驱动设计，管理可编辑的游戏数据，便于在编辑器中调整。
    - **Zenject** 或 **Dependency Injection** 插件：用于管理依赖关系，提升代码的可测试性和可维护性。
    - **DOTween** 或 **LeanTween**：用于实现高效的动画和过渡效果，提升游戏的视觉表现。
    - **ProBuilder** 或 **Tilemap**：用于快速构建和编辑棋盘和关卡，提升开发效率。

通过合理应用这些设计模式和工具，您能够创建一个灵活、可扩展且高效的游戏架构，支持复杂的游戏机制和丰富的玩家体验。