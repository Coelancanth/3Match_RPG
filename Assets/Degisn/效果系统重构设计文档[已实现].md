# 效果系统重构设计文档

## 一、重构目标

1. **配置驱动**
   - 将效果的参数从硬编码迁移到配置文件
   - 方便策划调整和平衡游戏
   - 支持快速添加和修改效果

2. **模块解耦**
   - 将效果的定义与实现分离
   - 降低修改成本
   - 提高代码复用性

3. **扩展性提升**
   - 支持效果的组合与连锁
   - 便于添加新的效果类型
   - 灵活的参数配置系统

## 二、核心架构

### 1. 配置系统 (EffectConfig)
```csharp
public class EffectConfig : ScriptableObject
{
public class EffectData
{
public string ID; // 效果唯一标识
public string Name; // 效果名称
public string Description; // 效果描述
public EffectType Type; // 效果类型
public EffectTriggerType TriggerType; // 触发类型
public int Range; // 影响范围
public int BaseDamage; // 基础伤害
public Dictionary<string, float> ElementModifiers; // 元素修正值
public List<string> ChainEffectIDs; // 连锁效果
public Dictionary<string, object> CustomParameters; // 自定义参数
}
}
```

### 2. 工厂模式 (EffectFactory)
- 负责根据配置创建效果实例
- 维护效果类型映射关系
- 支持反射创建效果实例

### 3. 效果基类 (Effect)
- 从配置读取基础属性
- 定义效果的通用接口
- 提供默认实现

### 4. 管理器 (EffectManager)
- 加载效果配置
- 注册和管理效果实例
- 处理效果队列
- 提供效果触发接口

## 三、配置示例
```yaml
Effects:
ID: effect_fireball
Name: 火球术
Description: 增强范围内的火元素，削弱范围内的水元素
Type: ElementChange
TriggerType: OnEliminate
Range: 2
BaseDamage: 1
ElementModifiers:
Fire: 1.5
Water: 0.5
ChainEffectIDs:
effect_steam
effect_burn
```


## 四、实现流程

1. **配置加载**
   - 游戏启动时加载EffectConfig
   - 解析配置数据
   - 初始化效果注册表

2. **效果创建**
   - 通过EffectFactory创建效果实例
   - 注入配置数据
   - 注册到EffectManager

3. **效果执行**
   - 检查触发条件
   - 获取影响范围
   - 应用效果修改
   - 触发连锁效果

## 五、后续优化方向

1. **效果细分**
   - 将效果进一步模块化
   - 支持更细粒度的配置
   - 实现效果组合系统

2. **参数系统**
   - 添加参数验证
   - 支持表达式计算
   - 实现动态参数

3. **连锁系统**
   - 优化连锁效果触发机制
   - 添加优先级控制
   - 支持条件触发

4. **可视化工具**
   - 开发效果编辑器
   - 提供效果预览
   - 支持实时调试

## 六、注意事项

1. **配置管理**
   - 确保配置文件放在正确的Resources目录下
   - 注意配置的版本控制
   - 做好配置的容错处理

2. **性能优化**
   - 缓存反射创建的实例
   - 优化效果队列处理
   - 控制连锁效果的递归深度

3. **调试支持**
   - 添加详细的日志输出
   - 提供效果执行追踪
   - 支持运行时调试